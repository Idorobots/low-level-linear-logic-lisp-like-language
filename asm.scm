;;; Linear-typed Lisp assembler

(load "utils.scm")
(load "vm.scm")
(load "ops.scm")
(load "macros.scm")

;; Assembly

(define (assemble startup code)
  (define (label-index ops label)
    (let loop ((i 0)
               (remaining ops))
      (cond ((null? remaining) (error (format "Nonexistant label ~s" label)))
            ((equal? label (car remaining)) i)
            ((symbol? (car remaining)) (loop i (cdr remaining)))
            (':else (loop (+ i 1) (cdr remaining))))))
  (let* ((flat (flatten (list ':init
                              (mc-call startup)
                              (op-halt)
                              code)))
         (labels (cons (cons ':halt :halt)
                       (map (lambda (label)
                              (cons label (label-index flat label)))
                            (filter symbol? flat))))
         (assembly (map (lambda (op)
                          (op labels))
                        (filter (lambda (x)
                                  (not (symbol? x)))
                                flat))))
    (list labels
          (map instruction-repr assembly)
          (map instruction-exec assembly))))

;; Execution

(define (run tag state startup code)
  (define (make-tag base offset)
    (if (<= offset 0)
        base
        (tagged base (format "+~s" offset))))
  (define (compute-labels labels ops)
    (let loop ((ls (reverse labels))
               (offset (- (length ops) 1))
               (acc '()))
      (cond ((< offset 0) acc)
            ((< offset (cdar ls)) (loop (cdr ls) offset acc))
            (':else (loop ls
                          (- offset 1)
                          (cons (make-tag (caar ls) (- offset (cdar ls)))
                                acc))))))
  (let* ((assembled (assemble startup code))
         (labels (car assembled))
         (disasm (cadr assembled))
         (ops (caddr assembled))
         (op-labels (compute-labels labels ops)))
    (debug (tagged tag "-labels") labels)
    (debug (tagged tag "-n-ops") (length ops))
    (let loop ((state state))
      (define (inc-pc state)
        (reg-set state pc (+ 1 (reg state pc))))
      (define (trace state pc)
        (define (print i)
          (--> (format "~a " i)
               (right-pad 20 " ")
               (display)))
        (print (list-ref op-labels pc))
        (print (list-ref disasm pc))
        (print (state-format state))
        (newline)
        state)
      (let ((curr-pc (reg state pc)))
        (if (equal? :halt curr-pc)
            (debug (tagged tag "-result") state)
            (--> state
                 (trace curr-pc)
                 ((list-ref ops curr-pc))
                 (inc-pc)
                 (loop)))))))
